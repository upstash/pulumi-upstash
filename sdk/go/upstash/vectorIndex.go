// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package upstash

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type VectorIndex struct {
	pulumi.CustomResourceState

	// The creation time of the vector index in UTC as unix timestamp.
	CreationTime pulumi.IntOutput `pulumi:"creationTime"`
	// The unique ID associated to the owner of this index.
	CustomerId pulumi.StringOutput `pulumi:"customerId"`
	// Size of the vector array.
	DimensionCount pulumi.IntOutput `pulumi:"dimensionCount"`
	// Associated endpoint of your index.
	Endpoint pulumi.StringOutput `pulumi:"endpoint"`
	// The number of maximum query operations you can perform in a day. Only query operations are included in query count.
	MaxDailyQueries pulumi.IntOutput `pulumi:"maxDailyQueries"`
	// The number of maximum update operations you can perform in a day. Only upsert operations are included in update count.
	MaxDailyUpdates pulumi.IntOutput `pulumi:"maxDailyUpdates"`
	// The maximum amount of monthly bandwidth for the index. Unit is bytes. `-1` if the limit is unlimited.
	MaxMonthlyBandwidth pulumi.IntOutput `pulumi:"maxMonthlyBandwidth"`
	// The number of maximum query operations you can perform per second. Only query operations are included in query count.
	MaxQueryPerSecond pulumi.IntOutput `pulumi:"maxQueryPerSecond"`
	// The number of maximum vectors in a read operation. Query and fetch operations are included in read operations.
	MaxReadsPerRequest pulumi.IntOutput `pulumi:"maxReadsPerRequest"`
	// The amount of maximum size for the total metadata sizes in your index.
	MaxTotalMetadataSize pulumi.IntOutput `pulumi:"maxTotalMetadataSize"`
	// The number of maximum that your index can contain.
	MaxVectorCount pulumi.IntOutput `pulumi:"maxVectorCount"`
	// The number of maximum vectors in a write operation. Only upsert operations are included in write operations.
	MaxWritesPerRequest pulumi.IntOutput `pulumi:"maxWritesPerRequest"`
	// The number of maximum write operations you can perform per second. Only upsert operations are included in write count.
	MaxWritesPerSecond pulumi.IntOutput `pulumi:"maxWritesPerSecond"`
	// Name of the index.
	Name pulumi.StringOutput `pulumi:"name"`
	// Readonly REST token to send request to the related index. You can't perform update operation with this token.
	ReadOnlyToken pulumi.StringOutput `pulumi:"readOnlyToken"`
	// The region where your index is deployed.
	Region pulumi.StringOutput `pulumi:"region"`
	// Monthly pricing of your index. Only available for fixed and pro plans.
	ReservedPrice pulumi.Float64Output `pulumi:"reservedPrice"`
	// Associated distance metric to calculate the similarity.
	SimilarityFunction pulumi.StringOutput `pulumi:"similarityFunction"`
	// REST token to send request to the related index.
	Token pulumi.StringOutput `pulumi:"token"`
	// Associated plan of the index. Either `free`, `paid`, `fixed` or `pro`.
	Type pulumi.StringOutput `pulumi:"type"`
}

// NewVectorIndex registers a new resource with the given unique name, arguments, and options.
func NewVectorIndex(ctx *pulumi.Context,
	name string, args *VectorIndexArgs, opts ...pulumi.ResourceOption) (*VectorIndex, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DimensionCount == nil {
		return nil, errors.New("invalid value for required argument 'DimensionCount'")
	}
	if args.Region == nil {
		return nil, errors.New("invalid value for required argument 'Region'")
	}
	if args.SimilarityFunction == nil {
		return nil, errors.New("invalid value for required argument 'SimilarityFunction'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource VectorIndex
	err := ctx.RegisterResource("upstash:index/vectorIndex:VectorIndex", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVectorIndex gets an existing VectorIndex resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVectorIndex(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VectorIndexState, opts ...pulumi.ResourceOption) (*VectorIndex, error) {
	var resource VectorIndex
	err := ctx.ReadResource("upstash:index/vectorIndex:VectorIndex", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VectorIndex resources.
type vectorIndexState struct {
	// The creation time of the vector index in UTC as unix timestamp.
	CreationTime *int `pulumi:"creationTime"`
	// The unique ID associated to the owner of this index.
	CustomerId *string `pulumi:"customerId"`
	// Size of the vector array.
	DimensionCount *int `pulumi:"dimensionCount"`
	// Associated endpoint of your index.
	Endpoint *string `pulumi:"endpoint"`
	// The number of maximum query operations you can perform in a day. Only query operations are included in query count.
	MaxDailyQueries *int `pulumi:"maxDailyQueries"`
	// The number of maximum update operations you can perform in a day. Only upsert operations are included in update count.
	MaxDailyUpdates *int `pulumi:"maxDailyUpdates"`
	// The maximum amount of monthly bandwidth for the index. Unit is bytes. `-1` if the limit is unlimited.
	MaxMonthlyBandwidth *int `pulumi:"maxMonthlyBandwidth"`
	// The number of maximum query operations you can perform per second. Only query operations are included in query count.
	MaxQueryPerSecond *int `pulumi:"maxQueryPerSecond"`
	// The number of maximum vectors in a read operation. Query and fetch operations are included in read operations.
	MaxReadsPerRequest *int `pulumi:"maxReadsPerRequest"`
	// The amount of maximum size for the total metadata sizes in your index.
	MaxTotalMetadataSize *int `pulumi:"maxTotalMetadataSize"`
	// The number of maximum that your index can contain.
	MaxVectorCount *int `pulumi:"maxVectorCount"`
	// The number of maximum vectors in a write operation. Only upsert operations are included in write operations.
	MaxWritesPerRequest *int `pulumi:"maxWritesPerRequest"`
	// The number of maximum write operations you can perform per second. Only upsert operations are included in write count.
	MaxWritesPerSecond *int `pulumi:"maxWritesPerSecond"`
	// Name of the index.
	Name *string `pulumi:"name"`
	// Readonly REST token to send request to the related index. You can't perform update operation with this token.
	ReadOnlyToken *string `pulumi:"readOnlyToken"`
	// The region where your index is deployed.
	Region *string `pulumi:"region"`
	// Monthly pricing of your index. Only available for fixed and pro plans.
	ReservedPrice *float64 `pulumi:"reservedPrice"`
	// Associated distance metric to calculate the similarity.
	SimilarityFunction *string `pulumi:"similarityFunction"`
	// REST token to send request to the related index.
	Token *string `pulumi:"token"`
	// Associated plan of the index. Either `free`, `paid`, `fixed` or `pro`.
	Type *string `pulumi:"type"`
}

type VectorIndexState struct {
	// The creation time of the vector index in UTC as unix timestamp.
	CreationTime pulumi.IntPtrInput
	// The unique ID associated to the owner of this index.
	CustomerId pulumi.StringPtrInput
	// Size of the vector array.
	DimensionCount pulumi.IntPtrInput
	// Associated endpoint of your index.
	Endpoint pulumi.StringPtrInput
	// The number of maximum query operations you can perform in a day. Only query operations are included in query count.
	MaxDailyQueries pulumi.IntPtrInput
	// The number of maximum update operations you can perform in a day. Only upsert operations are included in update count.
	MaxDailyUpdates pulumi.IntPtrInput
	// The maximum amount of monthly bandwidth for the index. Unit is bytes. `-1` if the limit is unlimited.
	MaxMonthlyBandwidth pulumi.IntPtrInput
	// The number of maximum query operations you can perform per second. Only query operations are included in query count.
	MaxQueryPerSecond pulumi.IntPtrInput
	// The number of maximum vectors in a read operation. Query and fetch operations are included in read operations.
	MaxReadsPerRequest pulumi.IntPtrInput
	// The amount of maximum size for the total metadata sizes in your index.
	MaxTotalMetadataSize pulumi.IntPtrInput
	// The number of maximum that your index can contain.
	MaxVectorCount pulumi.IntPtrInput
	// The number of maximum vectors in a write operation. Only upsert operations are included in write operations.
	MaxWritesPerRequest pulumi.IntPtrInput
	// The number of maximum write operations you can perform per second. Only upsert operations are included in write count.
	MaxWritesPerSecond pulumi.IntPtrInput
	// Name of the index.
	Name pulumi.StringPtrInput
	// Readonly REST token to send request to the related index. You can't perform update operation with this token.
	ReadOnlyToken pulumi.StringPtrInput
	// The region where your index is deployed.
	Region pulumi.StringPtrInput
	// Monthly pricing of your index. Only available for fixed and pro plans.
	ReservedPrice pulumi.Float64PtrInput
	// Associated distance metric to calculate the similarity.
	SimilarityFunction pulumi.StringPtrInput
	// REST token to send request to the related index.
	Token pulumi.StringPtrInput
	// Associated plan of the index. Either `free`, `paid`, `fixed` or `pro`.
	Type pulumi.StringPtrInput
}

func (VectorIndexState) ElementType() reflect.Type {
	return reflect.TypeOf((*vectorIndexState)(nil)).Elem()
}

type vectorIndexArgs struct {
	// Size of the vector array.
	DimensionCount int `pulumi:"dimensionCount"`
	// Name of the index.
	Name *string `pulumi:"name"`
	// The region where your index is deployed.
	Region string `pulumi:"region"`
	// Monthly pricing of your index. Only available for fixed and pro plans.
	ReservedPrice *float64 `pulumi:"reservedPrice"`
	// Associated distance metric to calculate the similarity.
	SimilarityFunction string `pulumi:"similarityFunction"`
	// Associated plan of the index. Either `free`, `paid`, `fixed` or `pro`.
	Type string `pulumi:"type"`
}

// The set of arguments for constructing a VectorIndex resource.
type VectorIndexArgs struct {
	// Size of the vector array.
	DimensionCount pulumi.IntInput
	// Name of the index.
	Name pulumi.StringPtrInput
	// The region where your index is deployed.
	Region pulumi.StringInput
	// Monthly pricing of your index. Only available for fixed and pro plans.
	ReservedPrice pulumi.Float64PtrInput
	// Associated distance metric to calculate the similarity.
	SimilarityFunction pulumi.StringInput
	// Associated plan of the index. Either `free`, `paid`, `fixed` or `pro`.
	Type pulumi.StringInput
}

func (VectorIndexArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vectorIndexArgs)(nil)).Elem()
}

type VectorIndexInput interface {
	pulumi.Input

	ToVectorIndexOutput() VectorIndexOutput
	ToVectorIndexOutputWithContext(ctx context.Context) VectorIndexOutput
}

func (*VectorIndex) ElementType() reflect.Type {
	return reflect.TypeOf((**VectorIndex)(nil)).Elem()
}

func (i *VectorIndex) ToVectorIndexOutput() VectorIndexOutput {
	return i.ToVectorIndexOutputWithContext(context.Background())
}

func (i *VectorIndex) ToVectorIndexOutputWithContext(ctx context.Context) VectorIndexOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VectorIndexOutput)
}

// VectorIndexArrayInput is an input type that accepts VectorIndexArray and VectorIndexArrayOutput values.
// You can construct a concrete instance of `VectorIndexArrayInput` via:
//
//	VectorIndexArray{ VectorIndexArgs{...} }
type VectorIndexArrayInput interface {
	pulumi.Input

	ToVectorIndexArrayOutput() VectorIndexArrayOutput
	ToVectorIndexArrayOutputWithContext(context.Context) VectorIndexArrayOutput
}

type VectorIndexArray []VectorIndexInput

func (VectorIndexArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VectorIndex)(nil)).Elem()
}

func (i VectorIndexArray) ToVectorIndexArrayOutput() VectorIndexArrayOutput {
	return i.ToVectorIndexArrayOutputWithContext(context.Background())
}

func (i VectorIndexArray) ToVectorIndexArrayOutputWithContext(ctx context.Context) VectorIndexArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VectorIndexArrayOutput)
}

// VectorIndexMapInput is an input type that accepts VectorIndexMap and VectorIndexMapOutput values.
// You can construct a concrete instance of `VectorIndexMapInput` via:
//
//	VectorIndexMap{ "key": VectorIndexArgs{...} }
type VectorIndexMapInput interface {
	pulumi.Input

	ToVectorIndexMapOutput() VectorIndexMapOutput
	ToVectorIndexMapOutputWithContext(context.Context) VectorIndexMapOutput
}

type VectorIndexMap map[string]VectorIndexInput

func (VectorIndexMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VectorIndex)(nil)).Elem()
}

func (i VectorIndexMap) ToVectorIndexMapOutput() VectorIndexMapOutput {
	return i.ToVectorIndexMapOutputWithContext(context.Background())
}

func (i VectorIndexMap) ToVectorIndexMapOutputWithContext(ctx context.Context) VectorIndexMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VectorIndexMapOutput)
}

type VectorIndexOutput struct{ *pulumi.OutputState }

func (VectorIndexOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VectorIndex)(nil)).Elem()
}

func (o VectorIndexOutput) ToVectorIndexOutput() VectorIndexOutput {
	return o
}

func (o VectorIndexOutput) ToVectorIndexOutputWithContext(ctx context.Context) VectorIndexOutput {
	return o
}

// The creation time of the vector index in UTC as unix timestamp.
func (o VectorIndexOutput) CreationTime() pulumi.IntOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.IntOutput { return v.CreationTime }).(pulumi.IntOutput)
}

// The unique ID associated to the owner of this index.
func (o VectorIndexOutput) CustomerId() pulumi.StringOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.StringOutput { return v.CustomerId }).(pulumi.StringOutput)
}

// Size of the vector array.
func (o VectorIndexOutput) DimensionCount() pulumi.IntOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.IntOutput { return v.DimensionCount }).(pulumi.IntOutput)
}

// Associated endpoint of your index.
func (o VectorIndexOutput) Endpoint() pulumi.StringOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.StringOutput { return v.Endpoint }).(pulumi.StringOutput)
}

// The number of maximum query operations you can perform in a day. Only query operations are included in query count.
func (o VectorIndexOutput) MaxDailyQueries() pulumi.IntOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.IntOutput { return v.MaxDailyQueries }).(pulumi.IntOutput)
}

// The number of maximum update operations you can perform in a day. Only upsert operations are included in update count.
func (o VectorIndexOutput) MaxDailyUpdates() pulumi.IntOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.IntOutput { return v.MaxDailyUpdates }).(pulumi.IntOutput)
}

// The maximum amount of monthly bandwidth for the index. Unit is bytes. `-1` if the limit is unlimited.
func (o VectorIndexOutput) MaxMonthlyBandwidth() pulumi.IntOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.IntOutput { return v.MaxMonthlyBandwidth }).(pulumi.IntOutput)
}

// The number of maximum query operations you can perform per second. Only query operations are included in query count.
func (o VectorIndexOutput) MaxQueryPerSecond() pulumi.IntOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.IntOutput { return v.MaxQueryPerSecond }).(pulumi.IntOutput)
}

// The number of maximum vectors in a read operation. Query and fetch operations are included in read operations.
func (o VectorIndexOutput) MaxReadsPerRequest() pulumi.IntOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.IntOutput { return v.MaxReadsPerRequest }).(pulumi.IntOutput)
}

// The amount of maximum size for the total metadata sizes in your index.
func (o VectorIndexOutput) MaxTotalMetadataSize() pulumi.IntOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.IntOutput { return v.MaxTotalMetadataSize }).(pulumi.IntOutput)
}

// The number of maximum that your index can contain.
func (o VectorIndexOutput) MaxVectorCount() pulumi.IntOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.IntOutput { return v.MaxVectorCount }).(pulumi.IntOutput)
}

// The number of maximum vectors in a write operation. Only upsert operations are included in write operations.
func (o VectorIndexOutput) MaxWritesPerRequest() pulumi.IntOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.IntOutput { return v.MaxWritesPerRequest }).(pulumi.IntOutput)
}

// The number of maximum write operations you can perform per second. Only upsert operations are included in write count.
func (o VectorIndexOutput) MaxWritesPerSecond() pulumi.IntOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.IntOutput { return v.MaxWritesPerSecond }).(pulumi.IntOutput)
}

// Name of the index.
func (o VectorIndexOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Readonly REST token to send request to the related index. You can't perform update operation with this token.
func (o VectorIndexOutput) ReadOnlyToken() pulumi.StringOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.StringOutput { return v.ReadOnlyToken }).(pulumi.StringOutput)
}

// The region where your index is deployed.
func (o VectorIndexOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Monthly pricing of your index. Only available for fixed and pro plans.
func (o VectorIndexOutput) ReservedPrice() pulumi.Float64Output {
	return o.ApplyT(func(v *VectorIndex) pulumi.Float64Output { return v.ReservedPrice }).(pulumi.Float64Output)
}

// Associated distance metric to calculate the similarity.
func (o VectorIndexOutput) SimilarityFunction() pulumi.StringOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.StringOutput { return v.SimilarityFunction }).(pulumi.StringOutput)
}

// REST token to send request to the related index.
func (o VectorIndexOutput) Token() pulumi.StringOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.StringOutput { return v.Token }).(pulumi.StringOutput)
}

// Associated plan of the index. Either `free`, `paid`, `fixed` or `pro`.
func (o VectorIndexOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *VectorIndex) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

type VectorIndexArrayOutput struct{ *pulumi.OutputState }

func (VectorIndexArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VectorIndex)(nil)).Elem()
}

func (o VectorIndexArrayOutput) ToVectorIndexArrayOutput() VectorIndexArrayOutput {
	return o
}

func (o VectorIndexArrayOutput) ToVectorIndexArrayOutputWithContext(ctx context.Context) VectorIndexArrayOutput {
	return o
}

func (o VectorIndexArrayOutput) Index(i pulumi.IntInput) VectorIndexOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VectorIndex {
		return vs[0].([]*VectorIndex)[vs[1].(int)]
	}).(VectorIndexOutput)
}

type VectorIndexMapOutput struct{ *pulumi.OutputState }

func (VectorIndexMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VectorIndex)(nil)).Elem()
}

func (o VectorIndexMapOutput) ToVectorIndexMapOutput() VectorIndexMapOutput {
	return o
}

func (o VectorIndexMapOutput) ToVectorIndexMapOutputWithContext(ctx context.Context) VectorIndexMapOutput {
	return o
}

func (o VectorIndexMapOutput) MapIndex(k pulumi.StringInput) VectorIndexOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VectorIndex {
		return vs[0].(map[string]*VectorIndex)[vs[1].(string)]
	}).(VectorIndexOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VectorIndexInput)(nil)).Elem(), &VectorIndex{})
	pulumi.RegisterInputType(reflect.TypeOf((*VectorIndexArrayInput)(nil)).Elem(), VectorIndexArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VectorIndexMapInput)(nil)).Elem(), VectorIndexMap{})
	pulumi.RegisterOutputType(VectorIndexOutput{})
	pulumi.RegisterOutputType(VectorIndexArrayOutput{})
	pulumi.RegisterOutputType(VectorIndexMapOutput{})
}
